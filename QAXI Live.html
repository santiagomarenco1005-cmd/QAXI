<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QAXI LIVE | Professional Video</title>
    
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-storage-compat.js"></script>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">

    <style>
        /* --- ESTÉTICA TITANIUM (PRO) --- */
        :root {
            --bg-core: #050505;
            --gold-main: #D4AF37;
            --glass-panel: rgba(20, 20, 20, 0.85);
            --border-light: 1px solid rgba(255, 255, 255, 0.08);
            --text-white: #ffffff;
            --text-gray: #94a3b8;
            --danger: #ef4444;
            --success: #10b981;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; outline: none; }

        body {
            background-color: #000;
            color: var(--text-white);
            font-family: 'Inter', sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* --- HEADER --- */
        header {
            height: 70px;
            padding: 0 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: var(--border-light);
            background: rgba(5, 5, 5, 0.9);
            z-index: 100;
        }

        .brand {
            font-family: 'Cinzel', serif;
            color: var(--gold-main);
            font-size: 1.4rem;
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .status-dot {
            width: 8px; height: 8px; 
            border-radius: 50%; 
            background: #333;
            transition: 0.3s;
        }
        .status-text { font-size: 0.8rem; color: var(--text-gray); margin-left: 8px; }

        /* Stage layout for Active Speaker */
        .stage { position:relative; width:100%; height:100%; display:flex; gap:12px; }
        .stage-main { flex:1; display:flex; align-items:center; justify-content:center; position:relative; }
        .stage-main video, .stage-main .avatar-placeholder { width:100%; height:100%; object-fit:cover; border-radius:10px; transform: none; }
        .mini-strip { width:260px; display:flex; flex-direction:column; gap:8px; padding:8px; overflow:auto; }
        .mini-item { width:100%; height:84px; display:flex; gap:8px; align-items:center; padding:6px; background:rgba(255,255,255,0.02); border-radius:8px; }
        .mini-item video, .mini-item .avatar-placeholder { width:120px; height:72px; border-radius:6px; object-fit:cover; }

        /* Avatar placeholder for when camera is off */
        .avatar-placeholder { display:flex; align-items:center; justify-content:center; background:linear-gradient(180deg,#111,#0b0b0b); color:var(--gold-main); font-weight:700; font-size:18px; }

        /* Chat drawer for mobile */
        #chat-drawer { position:fixed; left:0; right:0; bottom:-100%; height:45%; background:var(--glass-panel); border-top:1px solid rgba(255,255,255,0.04); transition:bottom 0.28s ease; z-index:1200; display:flex; flex-direction:column; }
        #chat-drawer.open { bottom:0; }

        /* Slimmer chat message bubbles */
        .msg-bubble{ display:flex; gap:8px; align-items:flex-start; padding:8px 10px; border-radius:10px; max-width:76%; margin:6px 0; font-size:13px; line-height:1.2; background:rgba(255,255,255,0.03); color:var(--text-white); }
        .msg-bubble.local{ margin-left:auto; background:linear-gradient(180deg, rgba(212,175,55,0.12), rgba(212,175,55,0.06)); color:#000; }
        .msg-bubble.remote{ margin-right:auto; }
        .chat-avatar{ width:34px; height:34px; border-radius:8px; display:flex; align-items:center; justify-content:center; font-weight:700; font-size:12px; }

        /* Controls bar (centered bottom, Meet-like) */
    .controls-bar { position: fixed; left: 50%; transform: translateX(-50%); bottom: 18px; display:flex; gap:12px; z-index:140; backdrop-filter: blur(6px); pointer-events: auto; }
        .controls-bar button { background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.06); width:56px; height:56px; padding:0; border-radius:50%; color:var(--text-white); display:flex; align-items:center; justify-content:center; font-size:18px; box-shadow:0 6px 18px rgba(0,0,0,0.6); }
        .controls-bar button:hover{ transform: translateY(-3px); }
        .controls-bar .btn-aux { width:50px; height:50px; }
        .controls-bar .btn-hang { background: linear-gradient(180deg,#ef4444,#c53030); border:none; color:#fff; width:56px; height:56px; font-size:18px; border-radius:50%; box-shadow:0 8px 20px rgba(197,33,33,0.35); }

        /* Active speaker highlight */
        .active-speaker { transform:scale(1.02); box-shadow:0 20px 60px rgba(0,0,0,0.6) inset; border:2px solid rgba(212,175,55,0.12); }

        /* Mobile responsive rules */
        @media(max-width:820px){
            aside { display:none !important; }
            .stage { gap:0; }
            .mini-strip { position:absolute; right:8px; top:80px; width:96px; height:auto; flex-direction:column; }
            .stage-main { width:100%; }
            .local-preview { width:220px; height:140px; bottom:80px; right:12px; left:auto; transform:none; }
            .controls-bar { bottom:10px; }
        }

        /* ensure no mirror for accurate left/right movement */
        #localVideo, #remoteVideo, #mainVideo { transform: none !important; }

        /* local preview container (Meet-like) */
        .local-preview { position: fixed; right: 24px; left: auto; transform: none; bottom: 18px; width: 300px; height: 180px; max-width:42vw; max-height:28vh; border-radius:12px; overflow:hidden; z-index:150; box-shadow:0 10px 40px rgba(0,0,0,0.6); border:1px solid rgba(255,255,255,0.04); background:rgba(0,0,0,0.35); }
        #localVideo { width:100%; height:100%; object-fit:cover; display:block; }
        /* ensure local preview is not mirrored */
        #localVideo { transform: none !important; -webkit-transform: none !important; }
        /* hand label/frame shown over local preview */
        .hand-frame { position: absolute; left: 12px; top: 10px; background: rgba(212,175,55,0.95); color:#000; padding:6px 10px; border-radius:14px; font-weight:700; font-size:13px; display:none; z-index:130; box-shadow:0 6px 18px rgba(0,0,0,0.5); }

        /* main placeholder styling */
        #main-placeholder { background: #000; color:var(--text-gray); }

        /* hand overlay on mini items */
        .mini-item { position: relative; }
        .mini-item .hand-overlay { position:absolute; top:6px; right:6px; width:28px; height:28px; border-radius:50%; background:rgba(212,175,55,0.95); display:flex; align-items:center; justify-content:center; color:#000; font-size:14px; z-index:130; box-shadow:0 4px 10px rgba(0,0,0,0.4); }

        /* minimalist adjustments */
        aside { background: transparent; border-left: none; }
        .controls-bar button { transition: transform .12s ease, background .12s ease; }
        .controls-bar button:active { transform: translateY(1px) scale(.98); }
        body.chat-hidden aside { display:none !important; }
        body.chat-hidden main { margin-right: 0; }
        /* chat-toggle: no color when inactive, gold when active */
        .chat-toggle { background: transparent !important; color: var(--text-white) !important; }
        .chat-toggle i { color: inherit !important; }
        .chat-toggle.chat-active { background: var(--gold-main) !important; color: #000 !important; }
        .chat-toggle.chat-active i { color: #000 !important; }
        /* also allow any control button to use the same active class */
        .btn-aux.chat-active { background: var(--gold-main) !important; color: #000 !important; }
        .btn-aux.chat-active i { color: #000 !important; }
        /* subtle pulse when a new message arrives */
        @keyframes chatPulse {
            0% { transform: scale(1); box-shadow: none; }
            50% { transform: scale(1.08); box-shadow: 0 6px 18px rgba(212,175,55,0.18); }
            100% { transform: scale(1); box-shadow: none; }
        }
        .chat-toggle.chat-pulse { animation: chatPulse 0.9s ease-in-out 0s 2; }

        /* --- LOBBY (ENTRADA ÚNICA) --- */
        #lobby-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, rgba(10,10,10,0.95), #000);
            z-index: 999;
            display: flex; justify-content: center; align-items: center;
            overflow: hidden;
        }
        /* subtle background logo with low visibility */
        #lobby-screen::before{
            content: '';
            position: absolute; inset: 0;
            background-image: url('icon.png');
            background-repeat: no-repeat;
            background-position: center 30%;
            /* larger but very subtle */
            background-size: 70vmin;
            opacity: 0.06;
            filter: blur(1px) saturate(0.9);
            pointer-events: none;
        }
        /* entry animations */
        @keyframes lobbyPop { from { transform: translateY(8px) scale(.98); opacity:0 } to { transform: translateY(0) scale(1); opacity:1 } }
        .entry-card { animation: lobbyPop 420ms cubic-bezier(.2,.9,.2,1) both; }

        .entry-card {
            width: 520px;
            padding: 28px 22px;
            background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
            backdrop-filter: blur(8px) saturate(1.05);
            border: 1px solid rgba(255,255,255,0.04);
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.6);
            transform-origin: center;
        }
        .btn-connect { transition: transform .16s ease, box-shadow .16s ease; }
        .btn-connect:hover { transform: translateY(-4px); box-shadow: 0 14px 40px rgba(212,175,55,0.12); }
        #copy-code-btn { transition: transform .12s ease, background .12s ease; }
        #copy-code-btn.copied { background: var(--gold-main); color:#000; transform: translateY(-2px) scale(1.02); }
        @keyframes copyPulse { 0%{ transform: scale(.98); opacity: .9 } 50%{ transform: scale(1.06); opacity: 1 } 100%{ transform: scale(1); opacity: .98 } }
        .entry-card h2{ font-size:24px; letter-spacing:1px; margin-bottom:8px; text-shadow:0 4px 18px rgba(0,0,0,0.6); }
        .entry-card .input-code{ box-shadow: inset 0 1px 0 rgba(255,255,255,0.02); }
        .entry-card .btn-connect{ transition: transform .14s ease, box-shadow .14s ease; }
        .entry-card .btn-connect:hover{ transform: translateY(-3px) scale(1.01); box-shadow: 0 12px 30px rgba(212,175,55,0.12); }

        .input-code {
            width: 100%;
            padding: 18px;
            margin: 30px 0 20px 0;
            background: #000;
            border: 1px solid #333;
            color: var(--gold-main);
            font-size: 1.1rem;
            text-align: center;
            letter-spacing: 1px;
            border-radius: 4px;
            transition: 0.3s;
            text-transform: uppercase;
        }
    </style>
    </head>
    <body>
        <div id="app-error-banner" style="display:none;position:fixed;top:12px;left:50%;transform:translateX(-50%);background:#111;border:1px solid rgba(255,255,255,0.06);padding:10px 16px;border-radius:8px;z-index:2000;color:var(--text-white);box-shadow:0 8px 30px rgba(0,0,0,0.6);">
            <span id="app-error-text" style="font-size:13px;opacity:0.9;">Error en la aplicación. Mira la consola.</span>
            <button id="app-error-dismiss" style="margin-left:10px;padding:6px 8px;border-radius:6px;border:none;background:var(--gold-main);color:#000;">Cerrar</button>
        </div>
        <header>
            <div style="display:flex;align-items:center;gap:12px;">
                <img src="icon.png" alt="Q" id="brand-logo" style="height:72px;width:72px;object-fit:contain;border-radius:8px;" />
                <div style="display:flex;align-items:center;margin-left:12px;color:var(--text-gray);gap:8px;">
                    <div id="header-code">Código: -</div>
                    <button id="copy-code-btn" onclick="copyHeaderCode()" title="Copiar código" style="background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--text-gray);padding:6px;border-radius:6px;display:flex;align-items:center;gap:6px;"><i class="fas fa-copy"></i></button>
                </div>
            </div>
            <div style="display:flex;align-items:center;gap:12px;">
                <div id="participants-count" class="status-text">Participantes: 0</div>
                <button onclick="openProLive()" style="padding:8px 12px;border-radius:8px;background:var(--gold-main);border:none;color:#000;font-weight:700;">QAXI Live PRO</button>
            </div>
        </header>

        <main style="flex:1;display:flex;gap:12px;overflow:hidden;">
            <section style="flex:1;display:flex;align-items:center;justify-content:center;position:relative;">
                <div class="video-wrapper" style="width:100%;height:100%;position:relative;">
                    <!-- wait message removed to reduce clutter -->
                    <div class="controls-bar">
                        <button id="btn-mic" class="btn-aux" onclick="toggleMic()" title="Silenciar/Activar micrófono"><i id="btn-mic-icon" class="fas fa-microphone"></i></button>
                        <button id="btn-cam" class="btn-aux" onclick="toggleCam()" title="Apagar/Encender cámara"><i id="btn-cam-icon" class="fas fa-video"></i></button>
                        <button id="btn-screen" class="btn-aux" onclick="shareScreen()" title="Compartir pantalla"><i class="fas fa-desktop"></i></button>
                        <button id="btn-hand" class="btn-aux" onclick="raiseHand()" title="Levantar/Bajar mano">✋</button>
                        <button class="btn-aux" onclick="openSettings()" title="Ajustes"><i class="fas fa-cog"></i></button>
                        <button id="mobile-chat-btn" onclick="toggleChat()" class="btn-aux chat-toggle" title="Chat"><i id="mobile-chat-icon" class="fas fa-comments"></i></button>
                        <button id="switch-camera-btn" onclick="switchFacingMode()" style="display:none" class="btn-aux" title="Cambiar cámara"><i class="fas fa-exchange-alt"></i></button>
                        <button id="btn-hang" class="btn-hang" onclick="hangUp()" title="Colgar"><i class="fas fa-power-off"></i></button>
                    </div>

                    <div class="stage">
                        <div class="stage-main" id="stage-main">
                            <video id="mainVideo" autoplay playsinline muted style="border-radius:10px;background:#000;object-fit:cover;display:none;"></video>
                        </div>
                        <div class="mini-strip" id="mini-strip">
                            <div id="remote-mini" class="mini-item" style="display:none">
                                <video id="remoteVideo" autoplay playsinline style="border-radius:6px;background:#000;object-fit:cover;"></video>
                            </div>
                            <div id="participants-mini" style="margin-top:6px;display:flex;gap:6px;flex-wrap:wrap"></div>
                        </div>
                    </div>

                    <div id="local-preview" class="local-preview" style="display:none;">
                        <video id="localVideo" autoplay muted playsinline style="border-radius:6px;background:#111;object-fit:cover;"></video>
                        <div id="hand-frame" class="hand-frame">✋ Mano levantada</div>
                    </div>
                </div>
            </section>

            <aside style="width:320px;display:flex;flex-direction:column;border-left:1px solid rgba(255,255,255,0.03);">
                <div style="padding:12px;border-bottom:1px solid rgba(255,255,255,0.03);display:flex;gap:8px;align-items:center;">
                    <input id="displayNameInput" placeholder="Tu nombre" style="flex:1;padding:8px;border-radius:4px;background:#000;border:1px solid #222;color:var(--text-white);" />
                </div>
                <div style="flex:1;display:flex;flex-direction:column;">
                    <div id="chatFeed" style="padding:12px;overflow:auto;flex:1;"></div>
                    <div style="padding:10px;border-top:1px solid rgba(255,255,255,0.03);display:flex;gap:8px;align-items:center;">
                        <input id="chatInput" placeholder="Escribe un mensaje..." style="flex:1;padding:8px;border-radius:4px;background:#000;border:1px solid #222;color:var(--text-white);" />
                        <button id="chat-send-btn" onclick="sendMsg()" disabled style="padding:8px 10px;background:var(--gold-main);border-radius:6px;border:none;color:#000;">Enviar</button>
                    </div>
                </div>
            </aside>
            <!-- low-bandwidth badge removed -->
        </main>

        <!-- Chat drawer (mobile) -->
        <div id="chat-drawer">
            <div style="padding:10px;border-bottom:1px solid rgba(255,255,255,0.03);display:flex;align-items:center;gap:8px;">
                <button onclick="toggleChatDrawer()" style="padding:8px;background:#222;border-radius:6px;border:1px solid #333;color:var(--text-white);">Cerrar</button>
                <div style="flex:1;text-align:center;color:var(--gold-main);font-weight:700;">Chat</div>
            </div>
            <div style="flex:1;overflow:auto;padding:10px;" id="chat-drawer-feed">
                <div id="chatFeedDrawer"></div>
            </div>
            <div style="padding:10px;border-top:1px solid rgba(255,255,255,0.03);display:flex;gap:8px;align-items:center;">
                <input id="chatInputDrawer" placeholder="Escribe un mensaje..." style="flex:1;padding:8px;border-radius:4px;background:#000;border:1px solid #222;color:var(--text-white);" />
                <button onclick="sendMsgDrawer()" style="padding:8px 10px;background:var(--gold-main);border-radius:6px;border:none;color:#000;">Enviar</button>
            </div>
        </div>

        <!-- Lobby overlay -->
        <div id="lobby-screen">
            <div class="entry-card">
                <img src="icon.png" alt="Q" style="height:72px;width:72px;object-fit:contain;border-radius:8px;margin:0 auto 10px;display:block;" />
                <h2 style="color:var(--gold-main);">Entrar A QAXI Live</h2>
                <div style="display:flex;gap:12px;align-items:center;justify-content:center;margin-top:18px;">
                    <div style="width:240px;height:140px;border-radius:8px;overflow:hidden;background:#000;border:1px solid #222;display:flex;align-items:center;justify-content:center;position:relative;">
                        <video id="lobbyLocalVideo" autoplay muted playsinline style="width:100%;height:100%;object-fit:cover;display:block;"></video>
                        <!-- unified avatar container: renderiza initials cuando no hay video -->
                        <div id="lobbyAvatar" style="display:none;width:100%;height:100%;position:absolute;inset:0;align-items:center;justify-content:center;">
                            <div id="lobbyAvatarInner" class="avatar-dynamic" style="width:100%;height:100%;">
                                <div class="initials"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <input id="displayNameLobby" placeholder="Tu nombre (visible)" style="width:100%;padding:10px;border-radius:8px;background:#000;border:1px solid #222;color:var(--text-white);margin-top:10px;margin-bottom:8px;" />
                <input id="roomInput" class="input-code" placeholder="Código de sala" />
                <div style="display:flex;gap:8px;justify-content:center;align-items:center;margin-top:12px;">
                    <div style="display:flex;gap:8px;align-items:center;margin-right:6px;">
                        <button id="lobby-mic-btn" onclick="toggleLobbyMic()" title="Activar/Desactivar micrófono" style="padding:10px;border-radius:8px;background:#222;border:1px solid #333;color:var(--text-white);"><i id="lobby-mic-icon" class="fas fa-microphone-slash"></i></button>
                        <button id="lobby-cam-btn" onclick="toggleLobbyCam()" title="Activar/Desactivar cámara" style="padding:10px;border-radius:8px;background:#222;border:1px solid #333;color:var(--text-white);"><i id="lobby-cam-icon" class="fas fa-video-slash"></i></button>
                    </div>
                    <button class="btn-connect" onclick="joinWithName()" style="padding:12px 20px;border-radius:8px;background:var(--gold-main);border:none;color:#000;font-weight:700;">Unirse</button>
                    <button class="btn-create" onclick="createNewRoomWithName()" style="padding:10px 16px;border-radius:8px;background:#222;border:1px solid #333;color:var(--text-white);">Crear</button>
                </div>
                <div id="error-msg" style="color:var(--danger);margin-top:8px;font-size:13px;"></div>
            </div>
        </div>

        <!-- PRO Live Overlay (full-screen, hidden by default) -->
        <div id="proLivePanel" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.85);z-index:2200;align-items:center;justify-content:center;">
            <div style="width:95%;height:88%;background:linear-gradient(180deg, #070707, #0b0b0b);border:1px solid rgba(255,255,255,0.04);border-radius:12px;overflow:hidden;display:flex;flex-direction:column;">
                <div style="display:flex;align-items:center;justify-content:space-between;padding:12px 16px;border-bottom:1px solid rgba(255,255,255,0.03);">
                    <div style="display:flex;gap:12px;align-items:center;"><div style="font-family:Cinzel, serif;color:var(--gold-main);font-weight:700;font-size:1.1rem;">QAXI Live PRO</div><div style="color:#aaa;font-size:0.9rem;">Interfaz amplia para reuniones</div></div>
                    <div style="display:flex;gap:8px;align-items:center;">
                        <input id="proRoomInput" placeholder="Código de sala (opcional)" style="padding:8px;border-radius:6px;border:1px solid #222;background:#050505;color:#ddd;">
                        <button onclick="createProRoom()" style="padding:8px 12px;border-radius:6px;background:var(--gold-main);border:none;color:#000;font-weight:700;">Crear</button>
                        <button onclick="joinProRoom()" style="padding:8px 12px;border-radius:6px;background:#222;border:1px solid #333;color:#fff;">Entrar</button>
                        <button onclick="closeProLive()" style="padding:8px 12px;border-radius:6px;background:#111;border:1px solid #333;color:#fff;">Cerrar</button>
                    </div>
                </div>
                <div style="flex:1;display:flex;gap:12px;">
                    <div style="flex:1;overflow:hidden;">
                        <iframe id="proLiveIframe" src="./QAXI%20Live.html" style="width:100%;height:100%;border:none;background:#000;" sandbox="allow-scripts allow-same-origin allow-forms allow-popups" allow="fullscreen; autoplay"></iframe>
                    </div>
                    <div style="width:360px;background:#0f0f0f;border-left:1px solid rgba(255,255,255,0.03);display:flex;flex-direction:column;padding:12px;">
                        <div style="font-weight:700;color:#ddd;margin-bottom:8px;">Reuniones</div>
                        <div id="proLiveMeetingsList" style="flex:1;overflow:auto;border:1px solid #222;border-radius:8px;padding:8px;background:#050505;"></div>
                        <div style="margin-top:8px;display:flex;gap:8px;">
                            <input id="proNewMeetingName" placeholder="Nombre (opcional)" style="flex:1;padding:8px;border-radius:6px;border:1px solid #222;background:#050505;color:#ddd;">
                            <button onclick="createLiveMeeting(true)" style="padding:8px 10px;border-radius:6px;background:var(--gold-main);border:none;color:#000;">Crear</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Device modal (hidden) -->
        <div id="device-modal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.6);align-items:center;justify-content:center;">
            <div style="background:var(--glass-panel);padding:16px;border-radius:8px;min-width:320px;">
                <h3>Ajustes de dispositivo</h3>
                <div style="display:flex;gap:8px;margin-top:8px;"><select id="videoSource" style="flex:1"></select><select id="audioSource" style="flex:1"></select></div>
                <div style="margin-top:12px;text-align:right;"><button onclick="applyDeviceChanges()" style="padding:8px 10px;background:var(--gold-main);border:none;border-radius:6px;color:#000;">Aplicar</button> <button onclick="closeSettings()" style="padding:8px 10px;background:#222;border:1px solid #333;border-radius:6px;color:var(--text-white);">Cerrar</button></div>
            </div>
        </div>

    <script>
    (function(){
            // Encapsula estado y funcionalidades en App para mantener limpio el scope global
            const App = {
                config: {
                    firebaseConfig: {
                        apiKey: "AIzaSyDbZAPtQioiXZzkiiIRrkrBkEPF440NMaE",
                        authDomain: "qaxi-93d6d.firebaseapp.com",
                        projectId: "qaxi-93d6d",
                        storageBucket: "qaxi-93d6d.firebasestorage.app",
                        messagingSenderId: "137240859996",
                        appId: "1:137240859996:web:73e14d28c77233be965d99",
                        measurementId: "G-C74Z1DWV54"
                    },
                    servers: { iceServers: [ { urls: ['stun:stun1.l.google.com:19302','stun:stun2.l.google.com:19302'] } ] }
                },
                state: {
                    db:null, storage:null, pc:null, localStream:null, remoteStream:null, roomId:null, clientId: null, isHost:false,
                    refs: { participants:null, hands:null, reactions:null, typing:null, messages:null },
                    lobbyPreview:null, lobbyMicStream:null, lobbyMicEnabled:false, lobbyJoinWithoutCamera:false, isSharing:false,
                    isMobile: /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent||'')
                },

                // Inicialización
                async init(){
                    // client id
                    this.state.clientId = localStorage.getItem('qaxi_clientId') || ('c_'+Math.random().toString(36).substr(2,9));
                    if(!localStorage.getItem('qaxi_clientId')) localStorage.setItem('qaxi_clientId', this.state.clientId);

                    // init firebase compat
                    try{ if(firebase.apps.length===0) firebase.initializeApp(this.config.firebaseConfig); this.state.db = firebase.firestore(); this.state.storage = firebase.storage(); }
                    catch(e){ console.warn('Firebase init failed', e); }

                    // wire up simple UI bindings that need modern handlers
                    document.getElementById('chatInput').addEventListener('keypress', (e)=>{ if(e.key==='Enter') this.sendMsg(); });
                    document.getElementById('chatInput').addEventListener('input', ()=>{ this._onTypingInput(); });
                    // faster chat: allow Enter to send from mobile drawer and mirror typing hook
                    const chatDrawerInp = document.getElementById('chatInputDrawer');
                    if(chatDrawerInp){
                        chatDrawerInp.addEventListener('keypress', (e)=>{ if(e.key==='Enter') window.sendMsgDrawer(); });
                        chatDrawerInp.addEventListener('input', ()=>{ this._onTypingInput(); });
                    }

                    // restore chat visibility: default HIDDEN unless user previously set '0'
                    const saved = localStorage.getItem('qaxi_chatHidden'); if(saved==='0') document.body.classList.remove('chat-hidden'); else document.body.classList.add('chat-hidden');

                    // mobile tweaks
                    if(this.state.isMobile){ document.body.style.overflow='auto'; const lv=document.getElementById('localVideo'); if(lv){ lv.style.width='140px'; lv.style.height='100px'; lv.style.right='16px'; lv.style.bottom='16px'; } }
                    // start lobby preview (non-blocking)
                    try{ this._startLobbyPreview(); }catch(e){}
                    // reflect lobby preview/mic icons after attempting preview
                    setTimeout(()=>{
                        try{
                            const ic=document.getElementById('lobby-cam-icon'); if(ic){ ic.className = (this.state.lobbyPreview ? 'fas fa-video' : 'fas fa-video-slash'); }
                            const im=document.getElementById('lobby-mic-icon'); if(im){ im.className = (this.state.lobbyMicEnabled ? 'fas fa-microphone' : 'fas fa-microphone-slash'); }
                        }catch(e){}
                    },500);
                    // show mobile-specific buttons and update chat icon color
                    setTimeout(()=>{
                        const mChat=document.getElementById('mobile-chat-btn'); const sw=document.getElementById('switch-camera-btn'); if(this.state.isMobile){ if(mChat) mChat.style.display='inline-flex'; if(sw) sw.style.display='inline-flex'; }
                        const icon = document.getElementById('mobile-chat-icon'); if(icon){ icon.style.color = document.body.classList.contains('chat-hidden') ? '' : 'var(--gold-main)'; }
                    },300);
                },

                // UI helpers
                updateStatus(text,color){ const el=document.getElementById('conn-text'); if(el) el.innerText=text; const dot=document.getElementById('conn-dot'); if(dot){ dot.style.background=color; dot.style.boxShadow=`0 0 10px ${color}`; } },
                // show error banner (message) and log
                _showError(msg){ try{ console.error('App error:', msg); const b = document.getElementById('app-error-banner'); const t = document.getElementById('app-error-text'); if(b && t){ t.innerText = String(msg||'Error en la aplicación. Mira la consola.'); b.style.display='flex'; } }catch(e){ console.error('failed to show banner', e); } },
                // safe set text by element id
                _setText(id, txt){ try{ const el = document.getElementById(id); if(el) el.innerText = String(txt||''); }catch(e){ console.warn('setText',id,e); } },
                // safe clear html
                _clearHtml(id){ try{ const el = document.getElementById(id); if(el) el.innerHTML = ''; }catch(e){ console.warn('clearHtml',id,e); } },

                // Lobby preview: show camera preview before joining (Meet-like)
                async _startLobbyPreview(){ try{ if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return; const stream = await navigator.mediaDevices.getUserMedia({ video:{ width:640, height:360 }, audio:false }); this.state.lobbyPreview = stream; const lv = document.getElementById('lobbyLocalVideo'); if(lv){ lv.srcObject = stream; lv.play().catch(()=>{}); lv.style.objectFit='cover'; lv.style.transform='none'; } }catch(e){ /* ignore preview errors */ } },
                _stopLobbyPreview(){ try{ if(this.state.lobbyPreview){ this.state.lobbyPreview.getTracks().forEach(t=>t.stop()); this.state.lobbyPreview = null; } const lv = document.getElementById('lobbyLocalVideo'); if(lv) lv.srcObject = null; }catch(e){} },

                // Room & WebRTC
                async connectToRoom(){
                    const input = document.getElementById('roomInput'); let id = input && input.value ? input.value.trim().toUpperCase() : ''; if(!id){ this._setText('error-msg', 'Introduce el código de sala para unirse.'); return; }
                    this.state.roomId = id;
                    document.querySelectorAll('.btn-connect').forEach(b=>b.disabled=true);
                    try{
                        // respect lobby selections: if user enabled lobby preview or mic, reuse those tracks
                        let stream = null;
                        try{
                            if(this.state.lobbyJoinWithoutCamera){
                                // user explicitly chose to join without camera: only attach audio
                                stream = new MediaStream();
                                if(this.state.lobbyMicEnabled && this.state.lobbyMicStream){ try{ this.state.lobbyMicStream.getAudioTracks().forEach(t=> stream.addTrack(t)); }catch(e){} }
                                else { try{ const a = await navigator.mediaDevices.getUserMedia({ audio:true }); a.getAudioTracks().forEach(t=> stream.addTrack(t)); }catch(e){} }
                            } else if(this.state.lobbyPreview){
                                // build a new stream from lobby preview video and possible lobby mic
                                stream = new MediaStream();
                                try{ this.state.lobbyPreview.getVideoTracks().forEach(t=> stream.addTrack(t)); }catch(e){}
                                if(this.state.lobbyMicEnabled && this.state.lobbyMicStream){ try{ this.state.lobbyMicStream.getAudioTracks().forEach(t=> stream.addTrack(t)); }catch(e){} }
                                else {
                                    try{ const a = await navigator.mediaDevices.getUserMedia({ audio:true }); a.getAudioTracks().forEach(t=> stream.addTrack(t)); }catch(e){}
                                }
                            } else if(this.state.lobbyMicEnabled && this.state.lobbyMicStream){
                                stream = new MediaStream(); try{ this.state.lobbyMicStream.getAudioTracks().forEach(t=> stream.addTrack(t)); }catch(e){}
                            } else {
                                // default: request audio+video so camera and mic permissions are requested
                                    try{ stream = await navigator.mediaDevices.getUserMedia({ video:true, audio:true }); }catch(e){ stream = null; }
                            }
                        }catch(e){ stream = null; }
                        if(stream) this._setLocalStream(stream); else this._setLocalStream(new MediaStream());
                        // ensure placeholder updates and show local on stage while waiting for remote
                        try{ this._updateCamPlaceholder(); /* do not set mainVideo to local stream to avoid duplicate camera */ }catch(e){}
                        document.getElementById('lobby-screen').style.display='none';
                        this._setText('header-code', 'Código: '+id);
                        try{ const mpn = document.getElementById('main-placeholder-name'); if(mpn) mpn.innerText = this._getDisplayName(); }catch(e){}
                        // connection status removed per user's preference
                        await this._joinOrCreate(id);
                    }catch(err){ console.error(err); this._setText('error-msg', 'Error: Permite cámara y micrófono.'); document.querySelectorAll('.btn-connect').forEach(b=>b.disabled=false); }
                },

                async createNewRoom(){ const id=this._generateRoomId(); document.getElementById('roomInput').value=id; await this.connectToRoom(); },

                async _joinOrCreate(roomName){
                    const db = this.state.db; if(!db) throw new Error('No DB');
                    const roomRef = db.collection('rooms').doc(roomName); this.state.roomRef = roomRef;
                    const snap = await roomRef.get();

                    // prepare refs
                    this.state.refs.participants = roomRef.collection('participants');
                    this.state.refs.hands = roomRef.collection('hands');
                    this.state.refs.reactions = roomRef.collection('reactions');
                    this.state.refs.typing = roomRef.collection('typing');
                    this.state.refs.messages = roomRef.collection('messages');

                    this._listenParticipants(); this._listenHands(); this._listenReactions(); this._listenTyping();

                    // set up RTCPeerConnection
                    const pc = new RTCPeerConnection(this.config.servers);
                    this.state.pc = pc;
                    // expose a safe reference for debugging in the console (idempotent)
                    try{ window._pc = window._pc || this.state.pc; }catch(e){}

                    // lightweight logging for debugging WebRTC lifecycle
                    try{
                        pc.addEventListener('icecandidate', ev => console.log('[QAXI][pc][icecandidate]', this.state.roomId, this.state.clientId, ev && ev.candidate ? (ev.candidate.toJSON ? ev.candidate.toJSON() : ev.candidate) : null));
                        pc.addEventListener('iceconnectionstatechange', ev => console.log('[QAXI][pc][iceConnectionState]', this.state.roomId, this.state.clientId, pc.iceConnectionState));
                        pc.addEventListener('connectionstatechange', ev => console.log('[QAXI][pc][connectionState]', this.state.roomId, this.state.clientId, pc.connectionState));
                        pc.addEventListener('signalingstatechange', ev => console.log('[QAXI][pc][signalingState]', this.state.roomId, this.state.clientId, pc.signalingState));
                        pc.addEventListener('track', ev => console.log('[QAXI][pc][track:event]', this.state.roomId, this.state.clientId, ev && ev.streams && ev.streams[0] ? 'stream' : ev));
                    }catch(e){ console.warn('pc logging attach failed', e); }

                    this.state.pc.ontrack = e => {
                        if(e.streams && e.streams[0]){
                            this.state.remoteStream = e.streams[0];
                            const rv=document.getElementById('remoteVideo');
                            rv.srcObject = this.state.remoteStream; rv.muted = true;
                            document.getElementById('remote-mini').style.display='flex';
                            this.updateStatus('En vivo','#10b981');
                            try{
                                const mainVideo = document.getElementById('mainVideo'); const mainPh = document.getElementById('main-placeholder');
                                if(mainVideo){ mainVideo.style.display='block'; mainVideo.srcObject = this.state.remoteStream; }
                                if(mainPh) mainPh.style.display='none';
                                this._startMonitoring(this.state.remoteStream, 'remote');
                            }catch(e){}
                        }
                        const _waitMsg_1 = document.getElementById('wait-msg'); if(_waitMsg_1) _waitMsg_1.style.display='none';
                    };
                    this.state.pc.onconnectionstatechange = ()=>{ const s=this.state.pc.connectionState; console.log('[QAXI][pc][onconnectionstatechange]', this.state.roomId, this.state.clientId, s); if(s==='connected') this.updateStatus('En vivo','#10b981'); if(s==='disconnected' || s==='failed') this.updateStatus('Desconectado','#ef4444'); };

                    // add local tracks
                    this.state.localStream.getTracks().forEach(t=> this.state.pc.addTrack(t, this.state.localStream));
                    // start monitoring local audio for active speaker
                    try{ this._startMonitoring(this.state.localStream, 'local', {local:true}); }catch(e){}

                    if(snap.exists){
                        // guest
                        const offer = snap.data().offer; await this.state.pc.setRemoteDescription(new RTCSessionDescription(offer));
                        const answer = await this.state.pc.createAnswer(); await this.state.pc.setLocalDescription(answer);
                        await roomRef.set({ answer: { type: answer.type, sdp: answer.sdp } }, { merge:true });

                        const offerCandidates = roomRef.collection('offerCandidates'); const answerCandidates = roomRef.collection('answerCandidates');
                        this.state.pc.onicecandidate = e=>{ console.log('[QAXI][pc][guest][onicecandidate]', this.state.roomId, this.state.clientId, e && e.candidate ? (e.candidate.toJSON ? e.candidate.toJSON() : e.candidate) : null); if(e.candidate) answerCandidates.add(e.candidate.toJSON()); };
                        offerCandidates.onSnapshot(s=> s.docChanges().forEach(c=>{ if(c.type==='added') this.state.pc.addIceCandidate(new RTCIceCandidate(c.doc.data())); }));
                    } else {
                        // host
                        this.state.isHost = true; const _waitMsg_2 = document.getElementById('wait-msg'); if(_waitMsg_2) _waitMsg_2.style.display='flex';
                        const offerCandidates = roomRef.collection('offerCandidates'); const answerCandidates = roomRef.collection('answerCandidates');
                        this.state.pc.onicecandidate = e=>{ console.log('[QAXI][pc][host][onicecandidate]', this.state.roomId, this.state.clientId, e && e.candidate ? (e.candidate.toJSON ? e.candidate.toJSON() : e.candidate) : null); if(e.candidate) offerCandidates.add(e.candidate.toJSON()); };
                        const offer = await this.state.pc.createOffer(); await this.state.pc.setLocalDescription(offer);
                        await roomRef.set({ offer:{type:offer.type,sdp:offer.sdp}, hostId:this.state.clientId });
                        roomRef.onSnapshot(async s=>{ const data=s.data(); if(!this.state.pc.currentRemoteDescription && data && data.answer){ await this.state.pc.setRemoteDescription(new RTCSessionDescription(data.answer)); const _waitMsg_3 = document.getElementById('wait-msg'); if(_waitMsg_3) _waitMsg_3.style.display='none'; this.updateStatus('En vivo','#10b981'); } });
                        answerCandidates.onSnapshot(s=> s.docChanges().forEach(c=>{ if(c.type==='added') this.state.pc.addIceCandidate(new RTCIceCandidate(c.doc.data())); }));
                    }

                    // start chat listener
                    this._listenMessages(roomName);
                    this._setText('header-code', 'Código: ' + roomName);

                    // add participant presence
                    await this._addParticipant();
                    // enable chat send button now that we're in a room
                    const sendBtn = document.getElementById('chat-send-btn'); if(sendBtn) sendBtn.disabled = false;
                },

                async _addParticipant(){
                    const ref = this.state.refs.participants; const name = this._getDisplayName();
                    await ref.doc(this.state.clientId).set({ joinedAt: firebase.firestore.FieldValue.serverTimestamp(), clientId:this.state.clientId, device:this.state.isMobile?'mobile':'desktop', ua:navigator.userAgent, name, color:this._colorFromId(this.state.clientId) });
                },

                _setLocalStream(stream){
                    try{ if(this.state.localStream){ this.state.localStream.getTracks().forEach(t=>t.stop()); } }catch(e){}
                    this.state.localStream = stream;
                    const lv = document.getElementById('localVideo');
                    if(lv){ try{ lv.srcObject = stream; lv.style.transform = 'none'; lv.style.webkitTransform = 'none'; lv.play().catch(()=>{}); }catch(e){} }
                    try{ const lp = document.getElementById('local-preview'); if(lp) { lp.style.display='block'; const av = lp.querySelector('.local-avatar'); if(av) av.remove(); } }catch(e){}
                    // ensure UI shows camera-on icon and start audio monitoring
                    try{ this._updateCamIcon(); }catch(e){}
                    try{ this._startMonitoring(stream, 'local', {local:true}); }catch(e){}
                    try{ this._updateCamPlaceholder(); }catch(e){}
                },

                // centralize camera icon state update
                _updateCamIcon(){
                    try{
                        const btnIcon = document.getElementById('btn-cam-icon');
                        const hasVideo = this.state.localStream && this.state.localStream.getVideoTracks && this.state.localStream.getVideoTracks().length;
                        if(btnIcon){ btnIcon.className = hasVideo ? 'fas fa-video' : 'fas fa-video-slash'; }
                    }catch(e){ console.warn('_updateCamIcon', e); }
                },

                // show placeholder when cam off
                _updateCamPlaceholder(){ const v = this.state.localStream && this.state.localStream.getVideoTracks()[0]; const ph = document.getElementById('local-preview'); const lv = document.getElementById('localVideo'); if(!ph) return; if(!v){ if(lv) lv.style.display='none'; ph.style.display='block'; // show simple avatar inside preview
                    let av = ph.querySelector('.local-avatar'); if(!av){ av = document.createElement('div'); av.className='local-avatar'; av.style.cssText = 'width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#0b0b0b,#111);color:#fff;'; av.innerHTML = `<div style="text-align:center;"><svg width="60" height="60" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 12C14.2091 12 16 10.2091 16 8C16 5.79086 14.2091 4 12 4C9.79086 4 8 5.79086 8 8C8 10.2091 9.79086 12 12 12Z" fill="#fff"/><path d="M4 20C4 16.6863 7.58172 14 12 14C16.4183 14 20 16.6863 20 20H4Z" fill="#fff"/></svg></div>`; ph.appendChild(av); }
                } else { if(lv) lv.style.display='block'; const av = ph.querySelector('.local-avatar'); if(av) av.remove(); ph.style.display='block'; } },

                

                // audio monitoring / active speaker
                _ensureAudioContext(){ if(!this.audioCtx){ try{ this.audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }catch(e){ console.warn('No AudioContext',e); } } },
                _startMonitoring(stream, id, opts={local:false}){
                    this._ensureAudioContext(); if(!this.audioCtx) return;
                    const src = this.audioCtx.createMediaStreamSource(stream);
                    const analyser = this.audioCtx.createAnalyser(); analyser.fftSize = 512; src.connect(analyser);
                    const panner = this.audioCtx.createStereoPanner(); src.connect(panner);
                    // important: do NOT connect local (self) monitoring to output to avoid hearing your own mic.
                    if(!opts.local){ panner.connect(this.audioCtx.destination); }
                    const data = new Uint8Array(analyser.frequencyBinCount);
                    this.state.audioNodes = this.state.audioNodes||{};
                    this.state.audioNodes[id] = { analyser, panner, data, lastLevel:0 };
                    if(!this._monitorTimer){ this._monitorTimer = setInterval(()=> this._sampleLevels(), 180); }
                },
                _sampleLevels(){ const nodes=this.state.audioNodes||{}; let topId=null; let topVal=0; for(const id in nodes){ const n=nodes[id]; n.analyser.getByteTimeDomainData(n.data); let sum=0; for(let i=0;i<n.data.length;i++){ const v = (n.data[i]-128)/128; sum += v*v; } const rms = Math.sqrt(sum / n.data.length); n.lastLevel = rms; if(rms>topVal){ topVal=rms; topId=id; } }
                    // raised threshold to avoid false positives from movement or noise
                    if(topVal>0.04 && topId){ this._setActiveSpeaker(topId); } else { this._clearActiveSpeaker(); }
                },
                _setActiveSpeaker(id){ if(this._activeSpeakerId===id) return; this._activeSpeakerId = id; // map id to video element
                    // NOTE: do NOT switch the main stage video when someone speaks — only highlight the correct mini/preview
                    try{ const lp = document.getElementById('local-preview'); if(lp) lp.style.display = (this.state.localStream && this.state.localStream.getVideoTracks()[0]) ? 'block' : 'block'; }catch(e){}
                    try{ document.getElementById('remote-mini').style.display=(this.state.remoteStream?'flex':'none'); }catch(e){}
                    // add highlight
                    Array.from(document.querySelectorAll('.mini-item, .local-preview')).forEach(n=>n.classList.remove('active-speaker'));
                    const target = id==='local' ? document.getElementById('local-preview') : document.getElementById('remote-mini'); if(target) target.classList.add('active-speaker');
                    // update panning based on position in mini-strip
                    this._applyPanning();
                },
                _clearActiveSpeaker(){ if(this._activeSpeakerId){ this._activeSpeakerId = null; Array.from(document.querySelectorAll('.mini-item')).forEach(n=>n.classList.remove('active-speaker')); Array.from(document.querySelectorAll('.avatar-pulse')).forEach(a=>a.classList.remove('avatar-pulse')); } },
                _applyPanning(){ const strip = document.getElementById('mini-strip'); if(!strip || !this.audioCtx || !this.state.audioNodes) return; const items = Array.from(strip.querySelectorAll('.mini-item')).filter(i=>i.offsetParent!==null);
                    items.forEach((it, idx)=>{ const audioKey = it.id==='local-mini' || it.id==='local-preview' ? 'local' : 'remote'; const node=this.state.audioNodes[audioKey]; if(node && node.panner){ const pan = (idx/(Math.max(1,items.length-1)))*2-1; node.panner.pan.value = pan; } });
                },

                // Controls
                toggleMic(){ const t = this.state.localStream && this.state.localStream.getAudioTracks()[0]; if(t){ t.enabled = !t.enabled; document.getElementById('btn-mic-icon').className = t.enabled ? 'fas fa-microphone' : 'fas fa-microphone-slash'; } },
                async toggleCam(){
                     try{
                         const hasLocal = !!this.state.localStream;
                         const currentVideo = hasLocal && this.state.localStream.getVideoTracks()[0];
                         const senders = this.state.pc? this.state.pc.getSenders() : [];
                         const vsender = senders.find(s=>s.track&&s.track.kind==='video');
 
                         if(currentVideo){
                             // TURN OFF: stop hardware camera track so LED turns off (covers other refs too)
                             this._stopAllCameraHardware();
                             // replace outgoing track with a silent black canvas stream
                             const canvas = document.createElement('canvas'); canvas.width = 640; canvas.height = 360; const ctx = canvas.getContext('2d'); ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
                             const dummyStream = canvas.captureStream(5);
                             const dummyTrack = dummyStream.getVideoTracks()[0];
                             if(vsender && dummyTrack) vsender.replaceTrack(dummyTrack);
                             // remove video tracks from localStream (keep audio)
                             const audioTracks = (this.state.localStream && this.state.localStream.getAudioTracks()) || [];
                             this.state.localStream = new MediaStream(audioTracks);
                             document.getElementById('localVideo').srcObject = this.state.localStream;
                             try{ this._updateCamIcon(); }catch(e){}
                             this._updateCamPlaceholder();
                         } else {
                             // TURN ON: request camera and replace sender track
                             const newStream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'user' }, audio:false });
                             const newTrack = newStream.getVideoTracks()[0];
                             if(vsender && newTrack) vsender.replaceTrack(newTrack);
                             // merge with existing audio tracks if any
                             const audio = (this.state.localStream && this.state.localStream.getAudioTracks()) || [];
                             const merged = new MediaStream([...(audio||[])]);
                             if(newTrack) merged.addTrack(newTrack);
                             // stop previous localStream tracks (already stopped earlier maybe)
                             if(this.state.localStream){ try{ this.state.localStream.getTracks().forEach(t=>{ if(t.readyState!=='ended') t.stop(); }); }catch(e){} }
                             this.state.localStream = merged;
                             const lv = document.getElementById('localVideo'); if(lv){ lv.srcObject = merged; try{ lv.style.transform='none'; lv.style.webkitTransform='none'; }catch(e){} }
                             try{ this._updateCamIcon(); }catch(e){}
                             this._startMonitoring(merged, 'local', {local:true});
                             this._updateCamPlaceholder();
                         }
                     }catch(e){ console.warn('toggleCam', e); try{ this._showError('No se pudo cambiar el estado de la cámara: '+(e && e.message ? e.message : String(e))); }catch(err){ console.error(err); } }
                 },
                // switch facing mode (mobile): toggles between user and environment
                async switchFacingMode(){ try{ const current = this.state.facingMode === 'environment' ? 'user' : 'environment'; this.state.facingMode = current; const constraints = { video:{ facingMode: { exact: current } }, audio:true };
                        const newStream = await navigator.mediaDevices.getUserMedia(constraints); const vTrack = newStream.getVideoTracks()[0]; const senders = this.state.pc? this.state.pc.getSenders() : []; const vsender = senders.find(s=>s.track&&s.track.kind==='video'); if(vsender && vTrack) vsender.replaceTrack(vTrack); if(this.state.localStream) this.state.localStream.getTracks().forEach(t=>t.stop()); this.state.localStream = newStream; document.getElementById('localVideo').srcObject = newStream; this._startMonitoring(newStream, 'local', {local:true}); try{ this._updateCamPlaceholder(); }catch(e){} }catch(e){ console.warn('switchFacing',e); alert('No se pudo cambiar cámara'); } },

                // Raise/Lower hand (toggle)
                async raiseHand(){ if(!this.state.refs.hands) return; try{
                        // if we already have a hand doc id stored, delete it (lower hand)
                        if(this.state.handDocId){ try{ await this.state.refs.hands.doc(this.state.handDocId).delete().catch(()=>{}); }catch(e){} this.state.handDocId = null; const hf=document.getElementById('hand-frame'); if(hf) hf.style.display='none'; try{ const btn=document.getElementById('btn-hand'); if(btn) btn.classList.remove('chat-active'); }catch(e){} return; }
                        // otherwise add a hand doc
                        const ref = await this.state.refs.hands.add({ clientId:this.state.clientId, name:this._getDisplayName(), timestamp:firebase.firestore.FieldValue.serverTimestamp() }); this.state.handDocId = ref.id; try{ const btn=document.getElementById('btn-hand'); if(btn){ btn.classList.add('chat-active'); } }catch(e){}
                        // show local hand-frame immediately
                        try{ const hf=document.getElementById('hand-frame'); if(hf) hf.style.display='block'; }catch(e){}
                        // auto-remove hand after 30s
                        setTimeout(async ()=>{ try{ if(this.state.handDocId){ await this.state.refs.hands.doc(this.state.handDocId).delete().catch(()=>{}); this.state.handDocId = null; const hf=document.getElementById('hand-frame'); if(hf) hf.style.display='none'; try{ const btn=document.getElementById('btn-hand'); if(btn) btn.classList.remove('chat-active'); }catch(e){} } }catch(e){} }, 30000);
                    }catch(e){ console.warn('raiseHand',e); }
                },
                _listenHands(){ if(!this.state.refs.hands) return; this.state.refs.hands.orderBy('timestamp').onSnapshot(s=>{ const list=[]; s.forEach(d=>list.push(Object.assign({id:d.id}, d.data()))); this._renderHandsQueue(list); }); },
                _renderHandsQueue(list){ const first = list[0]; const lv=document.getElementById('local-preview'); const rv=document.getElementById('remote-mini'); // clear overlays
                    try{ const hf = document.getElementById('hand-frame'); if(hf) hf.style.display='none'; }catch(e){}
                    [rv].forEach(el=>{ if(!el) return; const existing = el.querySelector('.hand-overlay'); if(existing) existing.remove(); el.style.boxShadow=''; el.style.outline=''; });
                    if(first){ if(first.clientId===this.state.clientId){ const hf = document.getElementById('hand-frame'); if(hf) { hf.style.display='block'; } } else { if(rv){ const o=document.createElement('div'); o.className='hand-overlay'; o.innerHTML='✋'; rv.appendChild(o); rv.style.outline='6px solid rgba(212,175,55,0.45)'; } } }
                    const container=document.getElementById('participants-mini'); if(!container) return; container.querySelectorAll('.hand-badge').forEach(n=>n.remove()); list.slice(0,3).forEach((it,idx)=>{ const el=document.createElement('div'); el.className='hand-badge'; el.style.marginLeft='6px'; el.style.padding='4px 6px'; el.style.borderRadius='12px'; el.style.background='rgba(212,175,55,0.95)'; el.style.color='#000'; el.style.fontSize='12px'; el.innerText=(idx+1)+'. '+(it.name||'Inv'); container.appendChild(el); }); },

                // Reactions
                async sendReaction(emoji){ if(!this.state.refs.reactions) return; await this.state.refs.reactions.add({ emoji, senderId:this.state.clientId, senderName:this._getDisplayName(), timestamp:firebase.firestore.FieldValue.serverTimestamp() }); },
                _listenReactions(){ if(!this.state.refs.reactions) return; this.state.refs.reactions.onSnapshot(s=> s.docChanges().forEach(c=>{ if(c.type==='added'){ this._showFloatingReaction(c.doc.data().emoji); setTimeout(()=>c.doc.ref.delete().catch(()=>{}),2500); } })); },
                _showFloatingReaction(emoji){
                    const container=document.querySelector('.video-wrapper'); if(!container) return;
                    const el=document.createElement('div');
                    el.style.position='absolute';
                    el.style.left='50%';
                    el.style.top=(10+Math.random()*12)+'%';
                    el.style.transform='translateX(-50%)';
                    el.style.fontSize='28px';
                    el.style.pointerEvents='none';
                    el.style.opacity='0';
                    el.style.transition='transform 0.25s ease, opacity 0.25s ease';
                    el.innerText=emoji;
                    container.appendChild(el);
                    requestAnimationFrame(()=>{ el.style.opacity='1'; el.style.transform='translateX(-50%) translateY(-6px)'; });
                    setTimeout(()=>{ el.style.opacity='0'; el.style.transform='translateX(-50%) translateY(-20px)'; },900);
                    setTimeout(()=>el.remove(),1300);
                },

                // Chat
                _listenMessages(room){
                    if(!this.state.db) return;
                    const col = this.state.db.collection('rooms').doc(room).collection('messages').orderBy('timestamp');
                    col.onSnapshot(s=>{
                        const feed=document.getElementById('chatFeed'); if(feed) feed.innerHTML='';
                        s.forEach(d=> this._renderMsg(d.data()));
                        // trigger pulse only for newly added remote messages when chat is hidden
                        try{
                            s.docChanges().forEach(c=>{
                                if(c.type==='added'){
                                    const data = c.doc.data();
                                    if(data && data.senderId && data.senderId!==this.state.clientId){
                                        // if chat is hidden, pulse toggles; if visible, clear any pulse
                                        if(document.body.classList.contains('chat-hidden')) this._triggerChatPulse();
                                        else this._clearChatPulse();
                                    }
                                }
                            });
                        }catch(e){}
                        feed.scrollTop = feed.scrollHeight;
                    });
                },
                async sendMsg(){ const input=document.getElementById('chatInput'); const txt = input.value.trim(); if(!txt) return; const name=this._getDisplayName(); const color=this._colorFromId(this.state.clientId); await this.state.db.collection('rooms').doc(this.state.roomId).collection('messages').add({ text:txt, timestamp:firebase.firestore.FieldValue.serverTimestamp(), senderId:this.state.clientId, senderName:name, senderColor:color }); input.value=''; this._setTyping(false); },
                _renderMsg(data){ const feed=document.getElementById('chatFeed'); const div=document.createElement('div'); const isLocal = data.senderId===this.state.clientId; div.className = isLocal ? 'msg-bubble local' : 'msg-bubble remote'; div.style.opacity='0'; div.style.transform='translateY(6px)'; const time = data.timestamp && data.timestamp.toDate ? data.timestamp.toDate() : (data.timestamp ? new Date(data.timestamp): null); const hh = time?(' '+time.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})) : ''; const label = data.senderName || (isLocal?'Tú':'Invitado'); const avatar=document.createElement('div'); avatar.className='chat-avatar'; avatar.style.background = data.senderColor || this._colorFromId(data.senderId||'x'); avatar.innerText = (label.split(' ').map(s=>s[0]).slice(0,2).join('')||'?').toUpperCase(); const txtDiv=document.createElement('div'); txtDiv.style.display='flex'; txtDiv.style.flexDirection='column'; txtDiv.style.gap='4px'; const who=document.createElement('div'); who.style.fontSize='12px'; who.style.opacity='0.9'; who.style.marginBottom='2px'; who.innerText=label+hh; const body=document.createElement('div'); body.innerText = data.text || ''; const preview=document.createElement('div'); preview.style.marginTop='6px'; if(data.fileUrl){ if((data.fileType||'').startsWith('image/')){ const im=document.createElement('img'); im.src=data.fileUrl; im.style.maxWidth='200px'; im.style.borderRadius='6px'; preview.appendChild(im); } else { const a=document.createElement('a'); a.href=data.fileUrl; a.target='_blank'; a.innerText=data.fileName||'Archivo'; preview.appendChild(a); } } else if(data.text){ const matches = (data.text.match(this._urlRegex())||[]); matches.forEach(u=>{ if(this._imageExt().test(u)){ const im=document.createElement('img'); im.src=u; im.style.maxWidth='200px'; im.style.borderRadius='6px'; preview.appendChild(im); } }); }
                    txtDiv.appendChild(who); txtDiv.appendChild(body); txtDiv.appendChild(preview);
                    if(isLocal) div.appendChild(txtDiv); else { div.appendChild(avatar); div.appendChild(txtDiv); }
                    feed.appendChild(div); requestAnimationFrame(()=>{ div.style.opacity='1'; div.style.transform='translateY(0)'; }); feed.scrollTop = feed.scrollHeight; if(!isLocal) this._notifyUnread(); },

                _renderMsgTo(data, container){ const div=document.createElement('div'); div.style.padding='6px 0'; div.style.borderBottom='1px solid rgba(255,255,255,0.02)'; div.innerText = (data.senderName||'Inv')+': '+(data.text||data.fileName||''); container.appendChild(div); },

                // files
                async onFileSelected(e){ const f = e.target.files && e.target.files[0]; if(!f) return; if(!this.state.roomId){ alert('Conéctate a una sala'); return; } const name = Date.now()+'_'+f.name; const ref = this.state.storage.ref().child(`rooms/${this.state.roomId}/files/${name}`); const upload = ref.put(f); upload.on('state_changed', null, err=>console.warn(err), async ()=>{ const url = await ref.getDownloadURL(); const meta = { text:'', fileName:f.name, fileUrl:url, fileType:f.type, timestamp:firebase.firestore.FieldValue.serverTimestamp(), senderId:this.state.clientId, senderName:this._getDisplayName(), senderColor:this._colorFromId(this.state.clientId) }; await this.state.db.collection('rooms').doc(this.state.roomId).collection('messages').add(meta); }); e.target.value=''; },

                // typing
                _onTypingInput(){ clearTimeout(this._typingTimer); this._setTyping(true); this._typingTimer = setTimeout(()=> this._setTyping(false), 800); },
                // detiene pistas de cámara físicas para asegurar que el LED se apague
                _stopAllCameraHardware(){
                    try{
                        if(this.state.localStream){
                            this.state.localStream.getVideoTracks().forEach(t=>{ try{ t.stop(); }catch(e){} });
                        }
                        if(this.state.lobbyPreview){
                            try{ this.state.lobbyPreview.getTracks().forEach(t=>{ try{ t.stop(); }catch(e){} }); }catch(e){}
                            this.state.lobbyPreview = null;
                            const lv = document.getElementById('lobbyLocalVideo'); if(lv) lv.srcObject = null;
                        }
                        const localV = document.getElementById('localVideo');
                        if(localV){
                            const hasVideo = (this.state.localStream && this.state.localStream.getVideoTracks && this.state.localStream.getVideoTracks().length);
                            if(!hasVideo){
                                // detach srcObject to help the device turn off LED
                                try{ localV.srcObject = (this.state.localStream && this.state.localStream.getAudioTracks && this.state.localStream.getAudioTracks().length) ? new MediaStream(this.state.localStream.getAudioTracks()) : null; }catch(e){}
                            }
                        }
                        try{ this._updateCamIcon(); }catch(e){}
                    }catch(e){ console.warn('_stopAllCameraHardware', e); }
                },
                // oculta/restaura la previsualización local SOLO para el usuario (cuando abre el chat)
                _toggleLocalPreviewForChat(showingChat){
                    try{
                        const lp = document.getElementById('local-preview');
                        if(!lp) return;
                        if(showingChat){ lp.dataset._hiddenByChat = '1'; lp.style.display = 'none'; }
                        else { if(lp.dataset._hiddenByChat){ lp.style.display = 'block'; delete lp.dataset._hiddenByChat; } }
                    }catch(e){}
                },
                _triggerChatPulse(){
                    try{
                        // add pulse class to all chat-toggle controls
                        const toggles = Array.from(document.querySelectorAll('.chat-toggle'));
                        toggles.forEach(el=> el.classList.add('chat-pulse'));
                        // auto-clear after 3s
                        clearTimeout(this._chatPulseTimer);
                        this._chatPulseTimer = setTimeout(()=> this._clearChatPulse(), 3000);
                    }catch(e){}
                },
                _clearChatPulse(){
                    try{ const toggles = Array.from(document.querySelectorAll('.chat-toggle')); toggles.forEach(el=> el.classList.remove('chat-pulse')); clearTimeout(this._chatPulseTimer); }catch(e){}
                },
                _setTyping(on){ if(!this.state.refs.typing || !this.state.roomId) return; const ref = this.state.refs.typing.doc(this.state.clientId); if(on) ref.set({ name:this._getDisplayName(), clientId:this.state.clientId, timestamp:firebase.firestore.FieldValue.serverTimestamp() }); else ref.delete().catch(()=>{}); },
                _listenTyping(){ if(!this.state.refs.typing) return; this.state.refs.typing.onSnapshot(s=>{ const names=[]; s.forEach(d=>{ if(d.id!==this.state.clientId) names.push(d.data().name||'Inv'); }); const el=document.getElementById('typing-indicator'); if(el){ if(names.length) el.innerText = names.slice(0,3).join(', ') + ' está escribiendo...'; else el.innerText=''; } }); },

                // participants
                _listenParticipants(){ if(!this.state.refs.participants) return; this.state.refs.participants.onSnapshot(s=>{ this._setText('participants-count', 'Participantes: '+s.size); this._renderParticipants(s); }); },
                _renderParticipants(snap){ const container=document.getElementById('participants-mini'); if(!container) return; container.innerHTML=''; snap.docs.slice(0,5).forEach(d=>{ const data=d.data(); const el=document.createElement('div'); el.className='part-avatar'; el.title = data.name||data.clientId; el.style.background = data.color || this._colorFromId(data.clientId||'x'); el.innerText = ''; container.appendChild(el); }); // update panning since participants/mini changes
                    try{ this._applyPanning(); }catch(e){}
                },

                // unread
                _notifyUnread(){ if(document.hidden){ this._unreadCount = (this._unreadCount||0)+1; this._updateUnreadBadge(); return; } const b=document.getElementById('chat-unread'); if(b) b.style.display='none'; },
                _updateUnreadBadge(){ let badge=document.getElementById('chat-unread'); if(!badge){ const header=document.querySelector('.chat-header'); badge=document.createElement('span'); badge.id='chat-unread'; badge.className='badge'; badge.style.marginLeft='8px'; header.appendChild(badge); } badge.innerText = this._unreadCount||0; badge.style.display = (this._unreadCount||0)>0 ? 'inline-block' : 'none'; },

                // device modal
                openSettings(){ document.getElementById('device-modal').style.display='flex'; this._populateDevices(); }, closeSettings(){ document.getElementById('device-modal').style.display='none'; },
                async _populateDevices(){ try{ const devices = await navigator.mediaDevices.enumerateDevices(); const vs=document.getElementById('videoSource'); const as=document.getElementById('audioSource'); if(!vs||!as) return; vs.innerHTML=''; as.innerHTML=''; devices.forEach(d=>{ const o=document.createElement('option'); o.value=d.deviceId; o.innerText = (d.label||d.kind); if(d.kind==='videoinput') vs.appendChild(o); if(d.kind==='audioinput') as.appendChild(o); }); }catch(e){ console.warn('enum',e); } },
                async applyDeviceChanges(){ const vs=document.getElementById('videoSource'); const as=document.getElementById('audioSource'); const vId=vs&&vs.value; const aId=as&&as.value; try{ const constraints = { video: vId?{ deviceId:{ exact:vId } }:true, audio: aId?{ deviceId:{ exact:aId } }:true }; const newStream = await navigator.mediaDevices.getUserMedia(constraints); const vTrack = newStream.getVideoTracks()[0]; const aTrack = newStream.getAudioTracks()[0]; const senders = this.state.pc? this.state.pc.getSenders() : []; const vsender = senders.find(s=>s.track&&s.track.kind==='video'); const asender = senders.find(s=>s.track&&s.track.kind==='audio'); if(vsender && vTrack) vsender.replaceTrack(vTrack); if(asender && aTrack) asender.replaceTrack(aTrack); if(this.state.localStream) this.state.localStream.getTracks().forEach(t=>t.stop()); this.state.localStream = newStream; document.getElementById('localVideo').srcObject=newStream; this.closeSettings(); }catch(e){ console.warn('apply devices', e); try{ this._showError('No se pudo aplicar el dispositivo: '+(e && e.message? e.message: String(e))); }catch(err){ console.error(err); } } },

                applyFilter(name){ const local=document.getElementById('localVideo'); if(!local) return; switch(name){ case 'blur': local.style.filter='blur(6px)'; break; case 'bw': local.style.filter='grayscale(1) contrast(1.05)'; break; case 'sepia': local.style.filter='sepia(0.6) contrast(1.02)'; break; default: local.style.filter='none'; } },

                // hang up (leave room)
                async hangUp(){ try{
                        // stop local tracks
                        if(this.state.localStream){ this.state.localStream.getTracks().forEach(t=>t.stop()); }
                        // close peer connection
                        if(this.state.pc){ try{ this.state.pc.close(); }catch(e){} this.state.pc = null; }
                    // clear audio monitoring interval
                    try{ if(this._monitorTimer){ clearInterval(this._monitorTimer); this._monitorTimer = null; } this.state.audioNodes = {}; }catch(e){}
                        // update UI
                        this.updateStatus('Desconectado','#ef4444');
                        // clear main and show placeholder
                        try{ const mv=document.getElementById('mainVideo'); if(mv){ mv.srcObject = null; mv.style.display='none'; } const mph=document.getElementById('main-placeholder'); if(mph) mph.style.display='flex'; }catch(e){}
                        document.getElementById('lobby-screen').style.display='flex';
                        // hide remote mini
                        try{ const rm=document.getElementById('remote-mini'); if(rm) rm.style.display='none'; const rv=document.getElementById('remoteVideo'); if(rv) rv.srcObject = null; }catch(e){}
                        // remove presence entry
                        try{ if(this.state.refs.participants) await this.state.refs.participants.doc(this.state.clientId).delete().catch(()=>{}); }catch(e){}
                    }catch(e){ console.warn('hangUp',e); }
                },

                // share screen and replace outgoing video track
                async shareScreen(){
                    try{
                        // if already sharing, ask to stop
                        if(this.state.isSharing){
                            const ok = confirm('¿Deseas dejar de compartir la pantalla?');
                            if(!ok) return;
                            // stop existing shared stream if any
                            const mainVideo = document.getElementById('mainVideo');
                            if(mainVideo && mainVideo.srcObject){ const s = mainVideo.srcObject; if(s && s.getTracks) s.getTracks().forEach(t=>t.stop()); }
                            const btn = document.getElementById('btn-screen'); if(btn) btn.classList.remove('chat-active');
                            // try to restore camera sender
                            if(this.state.localStream && this.state.localStream.getVideoTracks && this.state.localStream.getVideoTracks()[0] && this.state.pc){
                                const camTrack = this.state.localStream.getVideoTracks()[0];
                                const vsender = this.state.pc.getSenders().find(s=>s.track&&s.track.kind==='video');
                                if(vsender && camTrack) await vsender.replaceTrack(camTrack);
                            }
                            this.state.isSharing = false;
                            return;
                        }

                        if(!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia){ alert('Compartir pantalla no soportado en este navegador'); return; }
                        const screenStream = await navigator.mediaDevices.getDisplayMedia({ video:true });
                        const screenTrack = screenStream.getVideoTracks()[0];
                        const mainVideo = document.getElementById('mainVideo');
                        const rv = document.getElementById('remoteVideo');
                        if(mainVideo){ mainVideo.style.display='block'; mainVideo.srcObject = screenStream; }
                        if(rv) rv.style.display = 'none';
                        const btn = document.getElementById('btn-screen'); if(btn) btn.classList.add('chat-active');
                        this.state.isSharing = true;
                        if(this.state.pc){ const vsender = this.state.pc.getSenders().find(s=>s.track&&s.track.kind==='video'); if(vsender && screenTrack) await vsender.replaceTrack(screenTrack); }

                        screenTrack.onended = async ()=>{
                            try{
                                if(btn) btn.classList.remove('chat-active');
                                this.state.isSharing = false;
                                if(this.state.remoteStream){ if(mainVideo){ mainVideo.srcObject = this.state.remoteStream; mainVideo.style.display='block'; } if(rv) rv.style.display='block'; }
                                if(this.state.localStream && this.state.localStream.getVideoTracks && this.state.localStream.getVideoTracks()[0] && this.state.pc){
                                    const camTrack = this.state.localStream.getVideoTracks()[0];
                                    const vsender = this.state.pc.getSenders().find(s=>s.track&&s.track.kind==='video');
                                    if(vsender && camTrack) await vsender.replaceTrack(camTrack);
                                } else {
                                    try{ const camStream = await navigator.mediaDevices.getUserMedia({ video:true, audio:false }); this._setLocalStream(camStream); if(this.state.pc){ const vsender = this.state.pc.getSenders().find(s=>s.track&&s.track.kind==='video'); const camTrack = camStream.getVideoTracks()[0]; if(vsender && camTrack) await vsender.replaceTrack(camTrack); } }catch(e){}
                                }
                            }catch(e){ console.warn('restore cam after screenshare',e); }
                        };
                    }catch(e){ console.warn('shareScreen',e); alert('No se pudo compartir pantalla'); }
                },

                // utils
                _generateRoomId(len=6){ const chars='ABCDEFGHJKMNPQRSTUVWXYZ23456789'; let out=''; for(let i=0;i<len;i++) out+=chars.charAt(Math.floor(Math.random()*chars.length)); return out; },
                _getDisplayName(){ const local = localStorage.getItem('qaxi_displayName'); if(local) return local; const input=document.getElementById('displayNameInput'); if(input && input.value.trim()){ localStorage.setItem('qaxi_displayName', input.value.trim()); return input.value.trim(); } return 'User-'+this.state.clientId.slice(-4); },
                _colorFromId(id){ let h=0; for(let i=0;i<id.length;i++) h = id.charCodeAt(i) + ((h<<5)-h); const hue = Math.abs(h)%360; return `hsl(${hue} 80% 60%)`; },
                _imageExt(){ return /\.(jpeg|jpg|gif|png|webp)$/i; },
                _urlRegex(){ return /(https?:\/\/[^\s]+)/g; },

                // cleanup
                async cleanupRoom(){ if(!this.state.roomRef) return; try{ const cols=['offerCandidates','answerCandidates','messages','participants']; for(const c of cols){ const s = await this.state.roomRef.collection(c).get(); const batch=this.state.db.batch(); s.forEach(d=>batch.delete(d.ref)); await batch.commit(); } await this.state.roomRef.delete(); }catch(e){ console.warn('cleanup',e); } }
            };

            // expose a small set of global functions used by inline handlers
            window.connectToRoom = ()=>App.connectToRoom();
            window.createNewRoom = ()=>App.createNewRoom();
            window.toggleMic = ()=>App.toggleMic();
            window.toggleCam = ()=>App.toggleCam();
            window.raiseHand = ()=>App.raiseHand();
            window.sendReaction = (e)=>App.sendReaction(e);
            window.openSettings = ()=>App.openSettings();
            window.applyFilter = (n)=>App.applyFilter(n);
            window.applyDeviceChanges = ()=>App.applyDeviceChanges();
            window.closeSettings = ()=>App.closeSettings();
            window.sendMsg = ()=>{ if(!App.state.roomId){ const em=document.getElementById('error-msg'); if(em) em.innerText='Únete a una sala para enviar mensajes.'; else alert('Únete a una sala para enviar mensajes.'); return; } App.sendMsg(); };
            window.onFileSelected = (e)=>App.onFileSelected(e);
            // defensive global wrappers in case App.init throws: call only if available
            const _safe = (fn, ...a)=>{ try{ if(window.App && typeof window.App[fn]==='function') return window.App[fn](...a); else console.warn('App not ready:', fn); }catch(e){ console.error('safe call',fn,e); } };
            window.connectToRoom = ()=>_safe('connectToRoom');
            window.createNewRoom = ()=>_safe('createNewRoom');
            window.toggleMic = ()=>_safe('toggleMic');
            window.toggleCam = ()=>_safe('toggleCam');
            window.raiseHand = ()=>_safe('raiseHand');
            window.sendReaction = (e)=>_safe('sendReaction', e);
            window.openSettings = ()=>_safe('openSettings');
            window.applyFilter = (n)=>_safe('applyFilter', n);
            window.applyDeviceChanges = ()=>_safe('applyDeviceChanges');
            window.closeSettings = ()=>_safe('closeSettings');
            window.sendMsg = ()=>{ if(!window.App || !window.App.state || !window.App.state.roomId){ const em=document.getElementById('error-msg'); if(em) em.innerText='Únete a una sala para enviar mensajes.'; else alert('Únete a una sala para enviar mensajes.'); return; } _safe('sendMsg'); };
            window.onFileSelected = (e)=>_safe('onFileSelected', e);
            window.toggleChat = (s)=>{ 
                if(typeof s==='boolean'){ if(s) document.body.classList.add('chat-hidden'); else document.body.classList.remove('chat-hidden'); } 
                else document.body.classList.toggle('chat-hidden'); 
                const visible = !document.body.classList.contains('chat-hidden');
                // hide local preview for the local user when chat is visible (others still receive video)
                try{ App._toggleLocalPreviewForChat(visible); }catch(e){}
                const btn=document.getElementById('mobile-chat-btn'); if(btn) btn.title = visible ? 'Ocultar chat' : 'Abrir chat';
                // color/sync all chat-toggle elements when active
                try{
                    const toggles = Array.from(document.querySelectorAll('.chat-toggle'));
                    toggles.forEach(el=>{ if(visible) el.classList.add('chat-active'); else el.classList.remove('chat-active'); });
                }catch(e){}
                // if on mobile, ensure the chat drawer opens/closes with the chat state
                try{
                    const d = document.getElementById('chat-drawer');
                    if(d){ if(App.state.isMobile){ if(visible) d.classList.add('open'); else d.classList.remove('open'); } }
                }catch(e){}
                // opening chat clears incoming pulse
                try{ if(visible) App._clearChatPulse(); }catch(e){}
                try{ localStorage.setItem('qaxi_chatHidden', document.body.classList.contains('chat-hidden') ? '1':'0'); }catch(e){}
                if(visible) setTimeout(()=>{ const ci=document.getElementById('chatInput'); if(ci) ci.focus(); },260);
            };
            // Mobile drawer and camera facing controls
            window.toggleChatDrawer = ()=>{ const d=document.getElementById('chat-drawer'); if(!d) return; d.classList.toggle('open'); }
            window.sendMsgDrawer = ()=>{ const inp=document.getElementById('chatInputDrawer'); if(!inp) return; const v=inp.value.trim(); if(!v) return; if(!App.state.roomId){ alert('Únete a una sala para enviar mensajes.'); return; } App.state.db.collection('rooms').doc(App.state.roomId).collection('messages').add({ text:v, timestamp:firebase.firestore.FieldValue.serverTimestamp(), senderId:App.state.clientId, senderName:App._getDisplayName(), senderColor:App._colorFromId(App.state.clientId) }); inp.value=''; }
            window.switchFacingMode = ()=>App.switchFacingMode();
            window.hangUp = ()=>App.hangUp();
            window.shareScreen = ()=>App.shareScreen();

            // lobby controls (pre-join)
            window.toggleLobbyCam = async ()=>{
                try{
                    if(window.App && window.App.state && window.App.state.lobbyPreview){
                        try{ window.App._stopLobbyPreview(); }catch(e){}
                        // user stopped preview; treat as explicit "join without camera"
                        try{ window.App.state.lobbyJoinWithoutCamera = true; }catch(e){}
                        const av = document.getElementById('lobbyAvatar'); if(av) av.style.display='flex';
                        const ic=document.getElementById('lobby-cam-icon'); if(ic) ic.className='fas fa-video-slash';
                    } else {
                        try{ await window.App._startLobbyPreview(); try{ window.App.state.lobbyJoinWithoutCamera = false; }catch(e){}
                            const av = document.getElementById('lobbyAvatar'); if(av) av.style.display='none';
                            const ic=document.getElementById('lobby-cam-icon'); if(ic) ic.className='fas fa-video'; }catch(e){ console.warn('lobby cam',e); try{ window.App._showError('No se pudo activar la cámara: '+(e && e.message? e.message:String(e))); }catch(_){} }
                    }
                }catch(e){ console.error(e); }
            };
            window.toggleLobbyMic = async ()=>{
                try{
                    if(!window.App) return;
                    if(window.App.state.lobbyMicEnabled){
                        try{
                            if(window.App.state.lobbyMicStream){ window.App.state.lobbyMicStream.getTracks().forEach(t=>t.stop()); window.App.state.lobbyMicStream = null; }
                            window.App.state.lobbyMicEnabled = false;
                            const im=document.getElementById('lobby-mic-icon'); if(im) im.className='fas fa-microphone-slash';
                        }catch(e){ console.warn('stop lobby mic',e); }
                    } else {
                        try{
                            const s = await navigator.mediaDevices.getUserMedia({ audio:true }); window.App.state.lobbyMicStream = s; window.App.state.lobbyMicEnabled = true; const im=document.getElementById('lobby-mic-icon'); if(im) im.className='fas fa-microphone';
                        }catch(e){ console.warn('lobby mic',e); alert('No se pudo activar el micrófono'); }
                    }
                }catch(e){ console.error(e); }
            };

            // expose App to window so global wrappers can call its methods
            try{ window.App = App; }catch(e){}

            // file:// warning intentionally disabled per user request.
            // (Previously showed a banner recommending running a local server.)

            // global error handlers to report uncaught errors and keep UI responsive
            // lightweight bootstrap diagnostics available on window for remote inspection
            try{ window._appBootstrap = window._appBootstrap || { started: Date.now(), ready:false, errors:[] }; }catch(e){}

            window.addEventListener('error', (ev)=>{
                try{ window._appBootstrap = window._appBootstrap || { started: Date.now(), ready:false, errors:[] }; window._appBootstrap.errors.push(String(ev && ev.message ? ev.message : ev)); const b = document.getElementById('app-error-banner'); const t = document.getElementById('app-error-text'); if(b && t){ t.innerText = (ev && ev.message) ? ('Error: '+ev.message) : 'Error en la aplicación (revisa consola)'; b.style.display='flex'; } }catch(e){}
                console.error('Uncaught error', ev.error || ev.message || ev);
            });

            window.addEventListener('unhandledrejection', (ev)=>{
                try{ window._appBootstrap = window._appBootstrap || { started: Date.now(), ready:false, errors:[] }; const msg = (ev && ev.reason && ev.reason.message) ? ev.reason.message : String(ev.reason||ev); window._appBootstrap.errors.push(msg); const b = document.getElementById('app-error-banner'); const t = document.getElementById('app-error-text'); if(b && t){ t.innerText = (ev && ev.reason && ev.reason.message) ? ('Error: '+ev.reason.message) : 'Promise rejection (revisa consola)'; b.style.display='flex'; } }catch(e){}
                console.error('Unhandled rejection', ev.reason || ev);
            });
            try{
                window._appBootstrap = window._appBootstrap || { started: Date.now(), ready:false, errors:[] };
                App.init();
                window._appBootstrap.ready = true;
                try{ window._appReady = true; localStorage.setItem('_qaxi_app_ready', Date.now().toString()); }catch(e){}
            }catch(e){
                try{ window._appBootstrap = window._appBootstrap || { started: Date.now(), ready:false, errors:[] }; window._appBootstrap.errors.push(String(e && e.message ? e.message : e)); window._appReady = false; localStorage.setItem('_qaxi_app_error', JSON.stringify({ time: Date.now(), message: (e && e.message) ? e.message : String(e) })); }catch(err){}
                console.error('App.init failed', e);
                try{ const b = document.getElementById('app-error-banner'); const t = document.getElementById('app-error-text'); if(b && t){ t.innerText = 'Error inicializando: '+(e && e.message ? e.message : String(e)); b.style.display='flex'; } }catch(e){}
            }

            // allow dismissing the error banner
            try{ const dbtn = document.getElementById('app-error-dismiss'); if(dbtn) dbtn.addEventListener('click', ()=>{ const b=document.getElementById('app-error-banner'); if(b) b.style.display='none'; }); }catch(e){}
        })();
            // --- PRO Live helper functions (local-only fallback) ---
            function openProLive(){ try{ document.getElementById('proLivePanel').style.display='flex'; renderProMeetings(); }catch(e){console.warn(e);} }
            function closeProLive(){ try{ document.getElementById('proLivePanel').style.display='none'; }catch(e){console.warn(e);} }
            function _loadProMeetings(){ try{ return JSON.parse(localStorage.getItem('qaxi_live_meetings')||'[]'); }catch(e){return[];} }
            function _saveProMeetings(list){ try{ localStorage.setItem('qaxi_live_meetings', JSON.stringify(list||[])); }catch(e){} }
            function renderProMeetings(){ try{ const list=_loadProMeetings(); const cont=document.getElementById('proLiveMeetingsList'); if(!cont) return; cont.innerHTML=''; if(!list.length){ cont.innerHTML='<div style="color:#888; padding:8px;">No hay reuniones. Crea una nueva.</div>'; return; } list.slice().reverse().forEach(m=>{ const el=document.createElement('div'); el.style.padding='8px'; el.style.marginBottom='8px'; el.style.border='1px solid #222'; el.style.borderRadius='6px'; el.style.display='flex'; el.style.justifyContent='space-between'; el.style.alignItems='center'; el.innerHTML = `<div style="flex:1;cursor:pointer;color:#ddd;" onclick="joinProMeeting('${m.id}')"><div style='font-weight:700;color:#fff;'>${m.name||m.id}</div><div style='font-size:12px;color:#999;'>${new Date(m.created).toLocaleString()}</div></div><div style='display:flex;gap:6px;'><button onclick="joinProMeeting('${m.id}')" class='btn-aux' style='padding:6px;border-radius:6px;'>Entrar</button><button onclick="copyProLink('${m.id}')" class='btn-aux' style='padding:6px;border-radius:6px;'>Copiar</button></div>`; cont.appendChild(el); }); }catch(e){console.warn('renderProMeetings',e);} }
            function createProRoom(){ try{ const name = (document.getElementById('proNewMeetingName')||{value:''}).value || (document.getElementById('proRoomInput')||{value:''}).value || ''; const id = 'qaxi-' + Date.now().toString(36) + '-' + Math.random().toString(36).slice(2,8); const created = Date.now(); const list=_loadProMeetings(); list.push({id,name,created}); _saveProMeetings(list); renderProMeetings(); // open in iframe
                const iframe = document.getElementById('proLiveIframe'); if(iframe) iframe.src = `./QAXI%20Live.html?room=${encodeURIComponent(id)}`; document.getElementById('proRoomInput').value = id; document.getElementById('liveRoomName') && (document.getElementById('liveRoomName').innerText = name || id);
            }catch(e){console.error(e);} }
            function createProRoomQuick(){ createProRoom(); }
            function joinProRoom(){ try{ const val = (document.getElementById('proRoomInput')||{value:''}).value.trim(); if(!val) return alert('Ingresa el código de sala o selecciona una reunión.'); const iframe = document.getElementById('proLiveIframe'); if(iframe) iframe.src = `./QAXI%20Live.html?room=${encodeURIComponent(val)}`; document.getElementById('liveRoomName') && (document.getElementById('liveRoomName').innerText = val); }catch(e){console.warn(e);} }
            function joinProMeeting(id){ try{ const iframe = document.getElementById('proLiveIframe'); if(iframe) iframe.src = `./QAXI%20Live.html?room=${encodeURIComponent(id)}`; document.getElementById('proRoomInput').value = id; document.getElementById('liveRoomName') && (document.getElementById('liveRoomName').innerText = id); }catch(e){console.warn(e);} }
            function copyProLink(id){ try{ const url = `./QAXI%20Live.html?room=${encodeURIComponent(id)}`; navigator.clipboard.writeText(url).then(()=>alert('Enlace copiado al portapapeles')).catch(()=>prompt('Copiar enlace', url)); }catch(e){console.warn(e);} }
            // Save display name from lobby then join
            function joinWithName(){ try{ const name = (document.getElementById('displayNameLobby')||{value:''}).value.trim(); if(name) try{ localStorage.setItem('qaxi_displayName', name); }catch(e){}; window.connectToRoom && window.connectToRoom(); }catch(e){console.warn(e);} }
            function createNewRoomWithName(){ try{ const name = (document.getElementById('displayNameLobby')||{value:''}).value.trim(); if(name) try{ localStorage.setItem('qaxi_displayName', name); }catch(e){}; window.createNewRoom && window.createNewRoom(); }catch(e){console.warn(e);} }
            // Copy the code shown in header (after 'Código:')
            function copyHeaderCode(){ try{ const el = document.getElementById('header-code'); if(!el) return; const raw = el.innerText || el.textContent || ''; const parts = raw.split(':'); const code = parts.slice(1).join(':').trim(); if(!code || code==='-'){ alert('No hay código para copiar'); return; } navigator.clipboard.writeText(code).then(()=>{ const btn = document.getElementById('copy-code-btn'); if(btn){ btn.classList.add('copied'); setTimeout(()=>{ try{ btn.classList.remove('copied'); }catch(e){} },900); } try{ const tmp = document.createElement('div'); tmp.style.position='fixed'; tmp.style.top='18px'; tmp.style.left='50%'; tmp.style.transform='translateX(-50%)'; tmp.style.padding='8px 12px'; tmp.style.background='rgba(0,0,0,0.8)'; tmp.style.color='#fff'; tmp.style.borderRadius='8px'; tmp.style.zIndex=9999; tmp.innerText='Código copiado'; document.body.appendChild(tmp); setTimeout(()=>tmp.remove(),900); }catch(e){} }).catch(()=>{ prompt('Copiar código', code); }); }catch(e){console.warn(e);} }
        </script>

    <script>
    // SimpleRTC: minimal Firestore signaling and auto-join when URL contains ?room=
    (function(){
        window.SimpleRTC = {
            pc: null,
            roomRef: null,
            localStream: null,
            remoteStream: null,
            async join(roomId){
                try{
                    if(!roomId) throw new Error('no roomId');
                    if(!window.firebase || !firebase.firestore) return alert('Firebase no inicializado. Abre la página desde el servidor donde config esté presente.');
                    const db = firebase.firestore();
                    this.roomRef = db.collection('rooms').doc(roomId);

                    // If the main App exists, update its state so presence/listeners work
                    try{
                        if(window.App && window.App.state){
                            App.state.roomId = roomId;
                            App.state.roomRef = this.roomRef;
                            App.state.refs = App.state.refs || {};
                            App.state.refs.participants = this.roomRef.collection('participants');
                            // start the participant listener in the App if available
                            try{ if(typeof App._listenParticipants === 'function') App._listenParticipants(); }catch(e){}
                            // add our presence document so the UI shows participants
                            try{ if(typeof App._addParticipant === 'function') App._addParticipant().catch(()=>{}); }catch(e){}
                        }
                    }catch(e){}

                    // get media
                    try{ this.localStream = await navigator.mediaDevices.getUserMedia({video:true,audio:true}); }catch(e){ alert('Permite cámara y micrófono en el navegador.'); throw e; }
                    // show local preview if available
                    try{ const lv = document.getElementById('localVideo'); if(lv) lv.srcObject = this.localStream; }catch(e){}

                    this.pc = new RTCPeerConnection((window.App && App.config && App.config.servers) ? App.config.servers : { iceServers: [{ urls: ['stun:stun1.l.google.com:19302'] }] });
                    window._pc = this.pc;

                    // remote stream container
                    this.remoteStream = new MediaStream();
                    const rv = document.getElementById('remoteVideo'); if(rv) rv.srcObject = this.remoteStream;

                    this.pc.addEventListener('track', e => { e.streams[0] && e.streams[0].getTracks().forEach(t=> this.remoteStream.addTrack(t)); console.log('[SimpleRTC] track'); });

                    // add local tracks
                    this.localStream.getTracks().forEach(t=> this.pc.addTrack(t, this.localStream));

                    // ICE candidates -> Firestore
                    const offerCandidates = this.roomRef.collection('offerCandidates');
                    const answerCandidates = this.roomRef.collection('answerCandidates');

                    this.pc.addEventListener('icecandidate', event => {
                        if(!event.candidate) return;
                        const c = event.candidate.toJSON();
                        // if we are the offerer, push to offerCandidates, else to answerCandidates
                        if(this.isOfferer) offerCandidates.add(c).catch(()=>{}); else answerCandidates.add(c).catch(()=>{});
                    });

                    const roomSnap = await this.roomRef.get();
                    if(!roomSnap.exists){
                        // create offer
                        this.isOfferer = true;
                        const offer = await this.pc.createOffer();
                        await this.pc.setLocalDescription(offer);
                        await this.roomRef.set({ offer: { type: offer.type, sdp: offer.sdp } });

                        // listen for remote answer
                        this.roomRef.onSnapshot(async snap => {
                            const data = snap.data();
                            if(!this.pc.currentRemoteDescription && data && data.answer){
                                const answerDesc = new RTCSessionDescription(data.answer);
                                await this.pc.setRemoteDescription(answerDesc);
                                console.log('[SimpleRTC] remote answer applied');
                            }
                        });

                        // listen for answer candidates
                        answerCandidates.onSnapshot(snap => snap.docChanges().forEach(ch => { if(ch.type === 'added'){ const c = ch.doc.data(); this.pc.addIceCandidate(new RTCIceCandidate(c)).catch(()=>{}); } }));
                        console.log('[SimpleRTC] created room and offer');
                    } else {
                        // join existing -> accept offer and create answer
                        this.isOfferer = false;
                        const data = roomSnap.data();
                        if(data && data.offer){
                            await this.pc.setRemoteDescription(new RTCSessionDescription(data.offer));
                            const answer = await this.pc.createAnswer();
                            await this.pc.setLocalDescription(answer);
                            await this.roomRef.update({ answer: { type: answer.type, sdp: answer.sdp } });
                            // listen for offer candidates
                            const offerCandCol = this.roomRef.collection('offerCandidates');
                            offerCandCol.onSnapshot(snap => snap.docChanges().forEach(ch => { if(ch.type === 'added'){ const c = ch.doc.data(); this.pc.addIceCandidate(new RTCIceCandidate(c)).catch(()=>{}); } }));
                            console.log('[SimpleRTC] joined and answered');
                        } else {
                            console.warn('[SimpleRTC] room has no offer');
                        }
                        // also listen for answer candidates (in case late)
                        answerCandidates.onSnapshot(snap => snap.docChanges().forEach(ch => { if(ch.type === 'added'){ const c = ch.doc.data(); this.pc.addIceCandidate(new RTCIceCandidate(c)).catch(()=>{}); } }));
                    }

                    // basic connection state logging
                    this.pc.addEventListener('connectionstatechange', ()=> console.log('[SimpleRTC] connectionState', this.pc.connectionState));

                }catch(err){ console.error('[SimpleRTC] join error', err); }
            }
        };

        // Auto-join if ?room= present in URL after app ready
        (function autoJoinFromUrl(){
            const params = new URLSearchParams(location.search);
            const rid = params.get('room');
            if(!rid) return;
            const waitAndJoin = ()=>{
                if(window._appReady || (window.App && window.App.state)){
                    setTimeout(()=>{ try{ window.SimpleRTC.join(rid); }catch(e){ console.error(e); } }, 250);
                } else {
                    setTimeout(waitAndJoin, 200);
                }
            };
            waitAndJoin();
        })();
    })();
    </script>
</body>
</html>